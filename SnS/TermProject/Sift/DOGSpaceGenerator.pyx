# Inside the package we can directly use module name,
# while we must use Sift.`modulename` outside
# FIXME: (what's wrong with test.py inside this package?)
from ImagePreprocessing cimport gaussian_blur, decimation, DTYPE_t, SIGMA
from ImagePreprocessing import DTYPE
import numpy as np
cimport numpy as np
cimport cython


cdef class GaussianOctave:
    """
    The Gaussian octave generated by blurring an image repeatly.

    scales: DTYPE_t[:, :, ::1]
        (`nsca`+3) images (each image is called a 'scale') blurred from scales[0]
        with different Gaussian kernels.
    diff_scales: DTYPE_t[:, :, ::1]
        (`nsca`+2) images (each image is called a 'scale') by doing difference
        between two neighbored images in `scales`.
    nsca: int
        Number of keypoints, which satisfies: number of images in the octave =
        `nsca`+3
    sigma: double
        `sigma` is the basic Gaussian parameter which means the 'bottom' image
        in the 'bottom' octave is blurred from the original image by convoluting
        with G_\{sigma}(x,y).

    """
    cdef:
        DTYPE_t[:, :, ::1] scales
        DTYPE_t[:, :, ::1] diff_scales
        int nsca, nrows, ncols
        double sigma

    def __init__(self, DTYPE_t[:, ::1] input, int nsca, double sigma=SIGMA):
        cdef int s, r, c
        self.nrows = input.shape[0]
        self.ncols = input.shape[1]
        self.nsca = nsca
        self.sigma = sigma
        self.diff_scales = np.zeros([nsca + 2, self.nrows, self.ncols], dtype=DTYPE)
        self.scales = np.zeros([nsca + 3, self.nrows, self.ncols], dtype=DTYPE)

        self.scales[0] = input
        for s in range(1, nsca + 3):
            self.scales[s] = gaussian_blur(self.scales[s - 1],
                    (2 ** (2 * s / nsca) - 2 ** (2 * (s - 1) / nsca)) ** 0.5
                                           * sigma)
            for r in range(0, self.nrows):
                for c in range(0, self.ncols):
                    self.diff_scales[s - 1, r, c] = \
                        self.scales[s, r, c] - self.scales[s - 1, r, c]

    # TODO
    cdef tuple _find_exact_extremum(self, int s, int r, int c):
        return s, r, c

    # TODO: we should apply a threshold on minimum contrast; see the docstring.
    # TODO: type of threshold and its default value?
    cdef bint _is_low_contrast(self, int s, int r, int c, double threshold=0.03):
        """
        For the experiments in the 'SIFT' paper, all extrema with a value of
        |D(x, y, sigma)| less than 0.03 (which means the extrema are unstable
        with low contrast) were discarded, where D(x, y, sigma) is the Taylor
        expansion (up to the quadratic terms) of the scale-space function.

        """
        return False

    cdef list _find_extrema_points(self):
        cdef:
            list extrema_points = []
            int r, c, s, index = 0
            int ds, dr, dc
            bint is_extrema_point = True
        # For each point,
        for s in range(1, self.nsca + 1):
            for r in range(1, self.nrows - 1):
                for c in range(1, self.ncols - 1):
                    # we compare it with its 26 neighbors
                    # (here itself included, so 27 comparisons in all)
                    for ds in range(-1, 2):
                        for dr in range(-1, 2):
                            for dc in range(-1, 2):
                                if self.diff_scales[s, r, c] < \
                                   self.diff_scales[s + ds, r + dr, c + dc]:
                                    is_extrema_point = False
                                    break
                    if is_extrema_point:
                        (s, r, c) = self._find_exact_extremum(s, r, c)
                        if not self._is_low_contrast(s, r, c):
                            extrema_points.append((s, r, c))
        return extrema_points


cdef class GaussianPyramid:
    """ The Gaussian pyramid of an input image. """
    cdef GaussianOctave[:] octaves

    def __init__(self, DTYPE_t[:, ::1] input, int noct,
                 int nsca, double sigma=SIGMA):
        """
        :param input: input image (with buffer interface)
        :param noct: number of octaves
        :param nsca: number of scales in each octave - 3
        :param sigma: (default: SIGMA=1.6)
            the 'bottom' image in the 'bottom' octave is blurred from
            the original image `input` by convoluting with G_\{sigma}(x,y).

        """
        cdef:
            list octaves = []
            GaussianOctave octave
            int o
            DTYPE_t[:, ::1] first = gaussian_blur(input, sigma)
        for o in range(0, noct):
            octave = GaussianOctave(first, nsca, sigma)
            octaves.append(octave)
            first = decimation(octave.scales[nsca])

    # TODO
    cdef int[:, :, :] find_keypoints(self):
        pass
