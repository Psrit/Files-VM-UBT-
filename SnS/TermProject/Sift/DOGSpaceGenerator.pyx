# Inside the package we can directly use module name,
# while we must use Sift.`modulename` outside
# FIXME: (what's wrong with test.py inside this package?)
from ImagePreprocessing cimport gaussian_blur, decimation, DTYPE_t, SIGMA
from ImagePreprocessing import DTYPE
import numpy as np
cimport numpy as np
cimport cython


cdef class GaussianOctave:
    """
    The Gaussian octave generated by blurring an image repeatly.

    scales: DTYPE_t[:, :, ::1]
        (`nsca`+3) images (each image is called a 'scale') blurred from scales[0]
        with different Gaussian kernels.
    diff_scales: DTYPE_t[:, :, ::1]
        (`nsca`+2) images (each image is called a 'scale') by doing difference
        between two neighbored images in `scales`.
    nsca: int
        Number of keypoints, which satisfies: number of images in the octave =
        `nsca`+3
    sigma: double
        `sigma` is the basic Gaussian parameter which means the 'bottom' image
        in the 'bottom' octave is blurred from the original image by convoluting
        with G_\{sigma}(x,y).

    """
    cdef:
        DTYPE_t[:, :, ::1] scales
        DTYPE_t[:, :, ::1] diff_scales
        int nsca, nrows, ncols
        double sigma

    def __init__(self, DTYPE_t[:, ::1] input, int nsca, double sigma=SIGMA):
        cdef int s, r, c
        self.nrows = input.shape[0]
        self.ncols = input.shape[1]
        self.nsca = nsca
        self.sigma = sigma
        self.diff_scales = np.zeros([nsca + 2, self.nrows, self.ncols], dtype=DTYPE)
        self.scales = np.zeros([nsca + 3, self.nrows, self.ncols], dtype=DTYPE)

        self.scales[0] = input
        for s in range(1, nsca + 3):
            self.scales[s] = gaussian_blur(self.scales[s - 1],
                    (2 ** (2 * s / nsca) - 2 ** (2 * (s - 1) / nsca)) ** 0.5
                                           * sigma)
            for r in range(0, self.nrows):
                for c in range(0, self.ncols):
                    self.diff_scales[s - 1, r, c] = \
                        self.scales[s, r, c] - self.scales[s - 1, r, c]

    cdef tuple _find_exact_extremum(self, int s, int r, int c, int niter=5):
        cdef:
            double[:, :] deriv = np.zeros((3, 1), dtype=DTYPE)
            double[:, :] hessian3 = np.zeros((3, 3), dtype=DTYPE)
            double ds, dr, dc
            int i
            int new_s = s, new_r = r, new_c = c
            double value_of_exact_extremum

        for i in range(0, niter):
            # calculate the derivative vector:
            deriv[0, 0] = (self.diff_scales[s + 1, r, c] -
                       self.diff_scales[s - 1, r, c]) / 2
            deriv[1, 0] = (self.diff_scales[s, r + 1, c] -
                       self.diff_scales[s, r - 1, c]) / 2
            deriv[2, 0] = (self.diff_scales[s, r, c + 1] -
                       self.diff_scales[s, r, c - 1]) / 2

            # calculate the Hessian matrix (on s, r, c):
            # /ds^2
            hessian3[0, 0] = self.diff_scales[s + 1, r, c] + \
                self.diff_scales[s - 1, r, c] - 2 * self.diff_scales[s, r, c]
            # /dsdr
            hessian3[0, 1] = (self.diff_scales[s + 1, r + 1, c] +
                self.diff_scales[s - 1, r - 1, c] - self.diff_scales[s + 1, r - 1, c]
                - self.diff_scales[s - 1, r + 1, c]) / 4
            hessian3[1, 0] = hessian3[0, 1]
            # /dsdc
            hessian3[0, 2] = (self.diff_scales[s + 1, r, c + 1] +
                self.diff_scales[s - 1, r, c - 1] - self.diff_scales[s + 1, r, c - 1]
                - self.diff_scales[s - 1, r, c + 1]) / 4
            hessian3[2, 0] = hessian3[0, 1]
            # /dr^2
            hessian3[1, 1] = self.diff_scales[s, r + 1, c] + \
                self.diff_scales[s, r - 1, c] - 2 * self.diff_scales[s, r, c]
            # /drdc
            hessian3[1, 2] = (self.diff_scales[s, r + 1, c + 1] +
                self.diff_scales[s, r - 1, c - 1] - self.diff_scales[s, r - 1, c + 1]
                - self.diff_scales[s, r + 1, c - 1]) / 4
            hessian3[2, 1] = hessian3[1, 2]
            # /dc^2
            hessian3[2, 2] = self.diff_scales[s, r, c + 1] + \
                self.diff_scales[s, r, c - 1] - 2 * self.diff_scales[s, r, c]

            [[ds], [dr], [dc]] = -np.dot(np.linalg.inv(hessian3), deriv)

            if ds > 0.5 and s <= self.nsca - 1:
                new_s += 1
            elif ds < -0.5 and s >= 2:
                new_s -= 1

            if dr > 0.5 and r <= self.nrows - 3:
                new_r += 1
            elif dr < -0.5 and r >= 2:
                new_r -= 1

            if dc > 0.5 and c <= self.nrows - 3:
                new_r += 1
            elif dr < -0.5 and r >= 2:
                new_r -= 1

            value_of_exact_extremum = self.diff_scales[s, r, c] + np.dot(
                np.transpose(deriv), [[ds, dr, dc]]
            )[0] / 2

            # if (s, r, c) are unchanged:
            if new_s == s and new_r == r and new_c == c:
                break
            # else, update the coordinates and go on
            s = new_s
            r = new_r
            c = new_c

        return s, r, c, value_of_exact_extremum

    # TODO: we should apply a threshold on minimum contrast and stability; see the docstring.
    # TODO: type of threshold and its default value?
    cdef bint _is_low_contrast_or_unstable(self, int s, int r, int c,
                double v, double contrast_threshold=0.03, double stability_threshold=10):
        """
        For the experiments in the 'SIFT' paper, all extrema with a value of
        |D(x, y, sigma)| less than 0.03 (which means the extrema are unstable
        with low contrast) were discarded, where D(x, y, sigma) is the Taylor
        expansion (up to the quadratic terms) of the scale-space function.

        """
        cdef:
            double[:, ::1] hessian2 = np.zeros((2, 2), dtype=DTYPE)

        if abs(v) < contrast_threshold:
            return False

        hessian2[0, 0] = self.diff_scales[s, r + 1, c] + \
                self.diff_scales[s, r - 1, c] - 2 * self.diff_scales[s, r, c]
        hessian2[1, 1] = self.diff_scales[s, r, c + 1] + \
                self.diff_scales[s, r, c - 1] - 2 * self.diff_scales[s, r, c]
        hessian2[0, 1] = (self.diff_scales[s, r + 1, c + 1] +
                self.diff_scales[s, r - 1, c - 1] - self.diff_scales[s, r - 1, c + 1]
                - self.diff_scales[s, r + 1, c - 1]) / 4
        hessian2[1, 0] = hessian2[0, 1]

        if np.trace(hessian2) ** 2 / np.linalg.det(hessian2) \
                >= (stability_threshold + 1) ** 2 / stability_threshold:
            return False

        return True

    cdef list find_keypoints(self):
        cdef:
            list extrema_points = []
            int r, c, s, index = 0
            int ds, dr, dc
            bint is_extrema_point = True
        # For each point,
        for s in range(1, self.nsca + 1):
            for r in range(1, self.nrows - 1):
                for c in range(1, self.ncols - 1):
                    # we compare it with its 26 neighbors
                    # (here itself included, so 27 comparisons in all)
                    for ds in range(-1, 2):
                        for dr in range(-1, 2):
                            for dc in range(-1, 2):
                                if self.diff_scales[s, r, c] < \
                                   self.diff_scales[s + ds, r + dr, c + dc]:
                                    is_extrema_point = False
                                    break
                    if is_extrema_point:
                        (s, r, c, v) = self._find_exact_extremum(s, r, c)
                        if not self._is_low_contrast_or_unstable(s, r, c, v):
                            extrema_points.append((r, c))
        return extrema_points


cdef class GaussianPyramid:
    """ The Gaussian pyramid of an input image. """
    cdef:
        list octaves
        int noct

    def __init__(self, DTYPE_t[:, ::1] input, int noct,
                 int nsca, double sigma=SIGMA):
        """
        :param input: input image (with buffer interface)
        :param noct: number of octaves
        :param nsca: number of scales in each octave - 3
        :param sigma: (default: SIGMA=1.6)
            the 'bottom' image in the 'bottom' octave is blurred from
            the original image `input` by convoluting with G_\{sigma}(x,y).

        """
        cdef:
            GaussianOctave octave
            int o
            DTYPE_t[:, ::1] first = gaussian_blur(input, sigma)
        self.noct = noct
        self.octaves = []
        for o in range(0, noct):
            octave = GaussianOctave(first, nsca, sigma)
            self.octaves.append(octave)
            first = decimation(octave.scales[nsca])

    cdef list find_keypoints(self):
        """ return the list of keypoints, which are recorded in the form (r, c). """
        cdef:
            int o
            list keypoints = []
        for o in range(0, self.noct):
            keypoints.extend(self.octaves[o].find_keypoints())
        return keypoints
