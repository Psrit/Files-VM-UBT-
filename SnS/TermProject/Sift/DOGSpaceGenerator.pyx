# cython: profile=True

# Inside the package we can directly use module name,
# while we must use Sift.`modulename` outside
# # FIXME: (what's wrong with test.py inside this package?)
# from ImagePreprocessing cimport gaussian_blur, decimation, DTYPE_t, SIGMA
from ImagePreprocessing import DTYPE
cimport Math as mt
import numpy as np
cimport numpy as np
cimport cython


@cython.boundscheck(False)
@cython.wraparound(False)
cdef class GaussianOctave:
    """
    The Gaussian octave generated by blurring an image repeatly.

    scales: DTYPE_t[:, :, ::1]
        (`nsca`+3) images (each image is called a 'scale') blurred from scales[0]
        with different Gaussian kernels.
    diff_scales: DTYPE_t[:, :, ::1]
        (`nsca`+2) images (each image is called a 'scale') by doing difference
        between two neighbored images in `scales`.
    nsca: int
        Number of keypoints, which satisfies: number of images in the octave =
        `nsca`+3
    sigma: DTYPE_t
        `sigma` is the basic Gaussian parameter which means the 'bottom' image
        in the 'bottom' octave is blurred from the original image by convoluting
        with G_\{sigma}(x,y).

    """
    # moved to .pxd for debugging
    # cdef:
    #     DTYPE_t[:, :, ::1] scales
    #     readonly DTYPE_t[:, :, ::1] diff_scales
    #     int nsca, nrows, ncols
    #     DTYPE_t sigma

    def __init__(self, DTYPE_t[:, ::1] input, int nsca, DTYPE_t sigma):
        cdef int s, r, c
        self.nrows = input.shape[0]
        self.ncols = input.shape[1]
        self.nsca = nsca
        self.sigma = sigma
        self.diff_scales = np.zeros([nsca + 2, self.nrows, self.ncols], dtype=DTYPE)
        self.scales = np.zeros([nsca + 3, self.nrows, self.ncols], dtype=DTYPE)

        self.scales[0] = input
        for s in range(1, nsca + 3):
            self.scales[s] = gaussian_blur(self.scales[s - 1],
                    (2 ** (2.0 * s / nsca) - 2 ** (2.0 * (s - 1) / nsca)) ** 0.5
                                           * sigma)
            for r in range(0, self.nrows):
                for c in range(0, self.ncols):
                    self.diff_scales[s - 1, r, c] = \
                        self.scales[s, r, c] - self.scales[s - 1, r, c]

        print("Octave initialized. ")

    cdef tuple _find_exact_extremum(self, int s, int r, int c, int niter=5):
        cdef:
            DTYPE_t[:, ::1] deriv = np.zeros((3, 1), dtype=DTYPE)
            DTYPE_t[:, ::1] hessian3 = np.zeros((3, 3), dtype=DTYPE)
            DTYPE_t ds, dr, dc
            int i
            int new_s = s, new_r = r, new_c = c
            DTYPE_t value_of_exact_extremum

        for i in range(0, niter):
            # calculate the derivative vector:
            deriv[0, 0] = (self.diff_scales[s + 1, r, c] -
                       self.diff_scales[s - 1, r, c]) / 2
            deriv[1, 0] = (self.diff_scales[s, r + 1, c] -
                       self.diff_scales[s, r - 1, c]) / 2
            deriv[2, 0] = (self.diff_scales[s, r, c + 1] -
                       self.diff_scales[s, r, c - 1]) / 2

            # calculate the Hessian matrix (on s, r, c):
            # /ds^2
            hessian3[0, 0] = self.diff_scales[s + 1, r, c] + \
                self.diff_scales[s - 1, r, c] - 2 * self.diff_scales[s, r, c]
            # /dsdr
            hessian3[0, 1] = (self.diff_scales[s + 1, r + 1, c] +
                self.diff_scales[s - 1, r - 1, c] - self.diff_scales[s + 1, r - 1, c]
                - self.diff_scales[s - 1, r + 1, c]) / 4
            hessian3[1, 0] = hessian3[0, 1]
            # /dsdc
            hessian3[0, 2] = (self.diff_scales[s + 1, r, c + 1] +
                self.diff_scales[s - 1, r, c - 1] - self.diff_scales[s + 1, r, c - 1]
                - self.diff_scales[s - 1, r, c + 1]) / 4
            hessian3[2, 0] = hessian3[0, 1]
            # /dr^2
            hessian3[1, 1] = self.diff_scales[s, r + 1, c] + \
                self.diff_scales[s, r - 1, c] - 2 * self.diff_scales[s, r, c]
            # /drdc
            hessian3[1, 2] = (self.diff_scales[s, r + 1, c + 1] +
                self.diff_scales[s, r - 1, c - 1] - self.diff_scales[s, r - 1, c + 1]
                - self.diff_scales[s, r + 1, c - 1]) / 4
            hessian3[2, 1] = hessian3[1, 2]
            # /dc^2
            hessian3[2, 2] = self.diff_scales[s, r, c + 1] + \
                self.diff_scales[s, r, c - 1] - 2 * self.diff_scales[s, r, c]

            if abs(mt.det(hessian3, 3)) > 10 ** (-8):
                [[ds], [dr], [dc]] = -np.dot(np.linalg.inv(hessian3), deriv)
            # if the Hessian is noninvertible, simply let the offset vector to be 0:
            else:
                ds = 0
                dr = 0
                dc = 0

            if ds > 0.5 and s <= self.nsca - 1:
                new_s += 1
            elif ds < -0.5 and s >= 2:
                new_s -= 1

            if dr > 0.5 and r <= self.nrows - 3:
                new_r += 1
            elif dr < -0.5 and r >= 2:
                new_r -= 1

            if dc > 0.5 and c <= self.nrows - 3:
                new_r += 1
            elif dr < -0.5 and r >= 2:
                new_r -= 1

            value_of_exact_extremum = self.diff_scales[s, r, c] + \
                (deriv[0, 0] * ds + deriv[1, 0] * dr + deriv[2, 0] * dc) / 2

            # if (s, r, c) are unchanged:
            if new_s == s and new_r == r and new_c == c:
                break
            # else, update the coordinates and go on
            s = new_s
            r = new_r
            c = new_c

        return s, r, c, value_of_exact_extremum

    # TODO: we should apply a threshold on minimum contrast and stability; see the docstring.
    # TODO: type of threshold and its default value?
    cdef bint _is_low_contrast_or_unstable(self, int s, int r, int c,
                DTYPE_t v, DTYPE_t contrast_threshold=0.03, DTYPE_t stability_threshold=10):
        """
        For the experiments in the 'SIFT' paper, all extrema with a value of
        |D(x, y, sigma)| less than 0.03 (which means the extrema are unstable
        with low contrast) were discarded, where D(x, y, sigma) is the Taylor
        expansion (up to the quadratic terms) of the scale-space function.

        """
        cdef:
            DTYPE_t[:, ::1] hessian2 = np.zeros((2, 2), dtype=DTYPE)

        if abs(v) < contrast_threshold:
            return True

        hessian2[0, 0] = self.diff_scales[s, r + 1, c] + \
                self.diff_scales[s, r - 1, c] - 2 * self.diff_scales[s, r, c]
        hessian2[1, 1] = self.diff_scales[s, r, c + 1] + \
                self.diff_scales[s, r, c - 1] - 2 * self.diff_scales[s, r, c]
        hessian2[0, 1] = (self.diff_scales[s, r + 1, c + 1] +
                self.diff_scales[s, r - 1, c - 1] - self.diff_scales[s, r - 1, c + 1]
                - self.diff_scales[s, r + 1, c - 1]) / 4
        hessian2[1, 0] = hessian2[0, 1]

        if np.trace(hessian2) ** 2 / mt.det(hessian2, 2) \
                < (stability_threshold + 1) ** 2 / stability_threshold:
            return False

        return True

    cpdef list find_keypoints_in_octave(self):
        cdef:
            list extrema_points = []
            int r, c, s, index = 0
            int ds, dr, dc
            bint is_keypoint = True
            bint is_maximum = True
            bint is_minimum = True
        # For each point,
        for s in range(1, self.nsca + 1):
            for r in range(1, self.nrows - 1):
                for c in range(1, self.ncols - 1):
                    # we compare it with its 26 neighbors
                    # (here itself included, so 27 comparisons in all)
                    for ds in range(-1, 2):
                        for dr in range(-1, 2):
                            for dc in range(-1, 2):
                                if self.diff_scales[s, r, c] < \
                                   self.diff_scales[s + ds, r + dr, c + dc]:
                                    is_maximum = False
                                if self.diff_scales[s, r, c] > \
                                   self.diff_scales[s + ds, r + dr, c + dc]:
                                    is_minimum = False
                                is_keypoint = is_minimum or is_maximum
                                 # if the point cannot be a key point
                                if not is_keypoint:
                                    break
                            if not is_keypoint:
                                break
                        if not is_keypoint:
                            break
                    # if the point IS a key point
                    # (which means is_minimum OR is_maximum is True;
                    # say if is_maximum and is_minimum both are True,
                    # then the point must hava SAME value as all its
                    # neighbors, in which case the point is not a key point):
                    if is_keypoint and (is_maximum != is_minimum):
                        (s, r, c, v) = self._find_exact_extremum(s, r, c)
                        if not self._is_low_contrast_or_unstable(s, r, c, v):
                            extrema_points.append((s, r, c))

                    # RESET!!!
                    is_keypoint = True
                    is_maximum = True
                    is_minimum = True
        return extrema_points


@cython.boundscheck(False)
@cython.wraparound(False)
cdef class GaussianPyramid:
    """ The Gaussian pyramid of an input image. """
    # cdef:
    #     list octaves
    #     int noct

    def __init__(self, DTYPE_t[:, ::1] input, int noct,
                 int nsca, DTYPE_t sigma=SIGMA):
        """
        :param input: input image (with buffer interface)
            pixel values are normalize to [0, 1]
        :param noct: number of octaves
        :param nsca: number of scales in each octave - 3
        :param sigma: (default: SIGMA=1.6)
            the 'bottom' image in the 'bottom' octave is blurred from
            the original image `input` by convoluting with G_\{sigma}(x,y).

        """
        cdef:
            GaussianOctave octave
            int o
            DTYPE_t[:, ::1] first = gaussian_blur(input, sigma)
        self.noct = noct
        self.octaves = []
        for o in range(0, noct):
            octave = GaussianOctave(first, nsca, (2 ** o) * sigma)
            self.octaves.append(octave)
            first = decimation(octave.scales[nsca])
        print("Pyramid initialized. ")
        self.find_keypoints()

    cpdef list find_keypoints(self):
        """
        return the list of keypoints, which are recorded in the form:
        [[o=0, list of `(s, r, c)`], [o=1, list of `(s, r, c)`],...]

        """
        cdef:
            int o
            list keypoints = []
        print("Start finding keypoints...")
        for o in range(0, self.noct):
            keypoints.append([o, self.octaves[o].find_keypoints_in_octave()])
        print("keypoints: ", keypoints)
        return keypoints
